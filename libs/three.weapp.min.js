// three.weapp.min.js
// Three.js微信小程序适配版本，基于Three.js r122
// 注意：此文件通常很大，这里提供一个简化版本用于演示

// 基本数学工具
const _Math = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  clamp: function(value, min, max) {
    return Math.max(min, Math.min(max, value));
  },
  euclideanModulo: function(n, m) {
    return ((n % m) + m) % m;
  },
  mapLinear: function(x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
  }
};

// 三维向量类
class Vector3 {
  constructor(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  
  set(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }
  
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }
  
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }
  
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  
  cross(v) {
    const x = this.x, y = this.y, z = this.z;
    this.x = y * v.z - z * v.y;
    this.y = z * v.x - x * v.z;
    this.z = x * v.y - y * v.x;
    return this;
  }
}

// 四元数类
class Quaternion {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  
  setFromEuler(euler) {
    const x = euler.x, y = euler.y, z = euler.z;
    const c1 = Math.cos(x / 2);
    const c2 = Math.cos(y / 2);
    const c3 = Math.cos(z / 2);
    const s1 = Math.sin(x / 2);
    const s2 = Math.sin(y / 2);
    const s3 = Math.sin(z / 2);
    
    this.x = s1 * c2 * c3 + c1 * s2 * s3;
    this.y = c1 * s2 * c3 - s1 * c2 * s3;
    this.z = c1 * c2 * s3 + s1 * s2 * c3;
    this.w = c1 * c2 * c3 - s1 * s2 * s3;
    
    return this;
  }
  
  multiply(q) {
    return this.multiplyQuaternions(this, q);
  }
  
  multiplyQuaternions(a, b) {
    const qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;
    const qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;
    
    this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    
    return this;
  }
}

// 欧拉角类
class Euler {
  constructor(x = 0, y = 0, z = 0, order = 'XYZ') {
    this.x = x;
    this.y = y;
    this.z = z;
    this.order = order;
  }
  
  set(x, y, z, order) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.order = order || this.order;
    return this;
  }
}

// 矩阵类
class Matrix4 {
  constructor() {
    this.elements = [
      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1
    ];
  }
  
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;
    te[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;
    te[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;
    te[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;
    return this;
  }
  
  identity() {
    this.set(
      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1
    );
    return this;
  }
}

// 基本材质
class Material {
  constructor() {
    this.type = '';
    this.uuid = Math.random().toString(36).substring(2, 15);
    this.visible = true;
    this.transparent = false;
    this.opacity = 1;
  }
}

// 基本几何体
class BufferGeometry {
  constructor() {
    this.uuid = Math.random().toString(36).substring(2, 15);
    this.attributes = {};
  }
  
  setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  }
}

class BufferAttribute {
  constructor(array, itemSize) {
    this.array = array;
    this.itemSize = itemSize;
  }
}

// 基本网格
class Mesh {
  constructor(geometry, material) {
    this.geometry = geometry;
    this.material = material;
    this.position = new Vector3();
    this.rotation = new Euler();
    this.quaternion = new Quaternion();
    this.scale = new Vector3(1, 1, 1);
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
  }
}

// 点光源
class PointLight {
  constructor(color, intensity, distance, decay) {
    this.color = color || 0xffffff;
    this.intensity = intensity !== undefined ? intensity : 1;
    this.distance = distance !== undefined ? distance : 0;
    this.decay = decay !== undefined ? decay : 1;
    this.position = new Vector3();
  }
}

// 环境光
class AmbientLight {
  constructor(color, intensity) {
    this.color = color || 0xffffff;
    this.intensity = intensity !== undefined ? intensity : 1;
  }
}

// 场景
class Scene {
  constructor() {
    this.children = [];
  }
  
  add(object) {
    this.children.push(object);
    return this;
  }
  
  remove(object) {
    const index = this.children.indexOf(object);
    if (index !== -1) {
      this.children.splice(index, 1);
    }
    return this;
  }
}

// 相机
class PerspectiveCamera {
  constructor(fov, aspect, near, far) {
    this.fov = fov || 50;
    this.aspect = aspect || 1;
    this.near = near || 0.1;
    this.far = far || 2000;
    this.position = new Vector3();
    this.rotation = new Euler();
    this.quaternion = new Quaternion();
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
  }
  
  lookAt(x, y, z) {
    if (x.isVector3) {
      this.lookAt(x.x, x.y, x.z);
      return;
    }
    // 简化版lookAt
    this.position.set(x, y, z);
    return this;
  }
  
  updateProjectionMatrix() {
    // 简化版 - 不做任何操作
    return this;
  }
}

// 渲染器
class WebGLRenderer {
  constructor(parameters) {
    this.domElement = parameters.canvas || null;
    this.width = 0;
    this.height = 0;
    this.pixelRatio = 1;
  }
  
  setSize(width, height) {
    this.width = width;
    this.height = height;
    if (this.domElement) {
      this.domElement.width = width * this.pixelRatio;
      this.domElement.height = height * this.pixelRatio;
    }
    return this;
  }
  
  setPixelRatio(value) {
    this.pixelRatio = value;
    return this;
  }
  
  setClearColor(color) {
    // 简化版 - 仅存储值
    this.clearColor = color;
    return this;
  }
  
  render(scene, camera) {
    // 简化版 - 使用微信小程序接口绘制
    const gl = this.domElement.getContext('webgl');
    if (gl) {
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      // 实际渲染由小程序API处理
    }
    return this;
  }
  
  dispose() {
    // 清理资源
  }
}

// 群组
class Group {
  constructor() {
    this.position = new Vector3();
    this.rotation = new Euler();
    this.quaternion = new Quaternion();
    this.scale = new Vector3(1, 1, 1);
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.children = [];
    this.userData = {};
  }
  
  add(object) {
    this.children.push(object);
    return this;
  }
  
  remove(object) {
    const index = this.children.indexOf(object);
    if (index !== -1) {
      this.children.splice(index, 1);
    }
    return this;
  }
}

// 球体几何体
class SphereGeometry extends BufferGeometry {
  constructor(radius, widthSegments, heightSegments) {
    super();
    this.type = 'SphereGeometry';
    this.parameters = {
      radius: radius || 1,
      widthSegments: widthSegments || 32,
      heightSegments: heightSegments || 16
    };
    // 实际生成顶点数据需要更复杂的代码
    const positions = new Float32Array(widthSegments * heightSegments * 3 * 3);
    this.setAttribute('position', new BufferAttribute(positions, 3));
  }
}

// 环形几何体
class RingGeometry extends BufferGeometry {
  constructor(innerRadius, outerRadius, thetaSegments, phiSegments) {
    super();
    this.type = 'RingGeometry';
    this.parameters = {
      innerRadius: innerRadius || 0.5,
      outerRadius: outerRadius || 1,
      thetaSegments: thetaSegments || 32,
      phiSegments: phiSegments || 1
    };
    // 实际生成顶点数据需要更复杂的代码
    const positions = new Float32Array(thetaSegments * 3 * 3);
    this.setAttribute('position', new BufferAttribute(positions, 3));
  }
}

// 纹理
class Texture {
  constructor(image) {
    this.image = image;
    this.uuid = Math.random().toString(36).substring(2, 15);
  }
}

class CanvasTexture extends Texture {
  constructor(canvas) {
    super(canvas);
    this.type = 'CanvasTexture';
  }
}

// 材质
class MeshBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = 'MeshBasicMaterial';
    this.color = 0xffffff;
    this.map = null;
    this.wireframe = false;
    
    if (parameters) {
      if (parameters.color !== undefined) this.color = parameters.color;
      if (parameters.map !== undefined) this.map = parameters.map;
      if (parameters.wireframe !== undefined) this.wireframe = parameters.wireframe;
      if (parameters.transparent !== undefined) this.transparent = parameters.transparent;
      if (parameters.opacity !== undefined) this.opacity = parameters.opacity;
      if (parameters.side !== undefined) this.side = parameters.side;
      if (parameters.emissive !== undefined) this.emissive = parameters.emissive;
      if (parameters.emissiveIntensity !== undefined) this.emissiveIntensity = parameters.emissiveIntensity;
    }
  }
}

class MeshStandardMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = 'MeshStandardMaterial';
    this.color = 0xffffff;
    this.roughness = 1.0;
    this.metalness = 0.0;
    this.map = null;
    
    if (parameters) {
      if (parameters.color !== undefined) this.color = parameters.color;
      if (parameters.roughness !== undefined) this.roughness = parameters.roughness;
      if (parameters.metalness !== undefined) this.metalness = parameters.metalness;
      if (parameters.map !== undefined) this.map = parameters.map;
    }
  }
}

class PointsMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = 'PointsMaterial';
    this.color = 0xffffff;
    this.size = 1.0;
    this.sizeAttenuation = true;
    
    if (parameters) {
      if (parameters.color !== undefined) this.color = parameters.color;
      if (parameters.size !== undefined) this.size = parameters.size;
      if (parameters.sizeAttenuation !== undefined) this.sizeAttenuation = parameters.sizeAttenuation;
      if (parameters.transparent !== undefined) this.transparent = parameters.transparent;
      if (parameters.opacity !== undefined) this.opacity = parameters.opacity;
    }
  }
}

// 点集
class Points {
  constructor(geometry, material) {
    this.geometry = geometry;
    this.material = material;
    this.position = new Vector3();
    this.rotation = new Euler();
    this.quaternion = new Quaternion();
    this.scale = new Vector3(1, 1, 1);
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
  }
}

// 时钟
class Clock {
  constructor(autoStart) {
    this.autoStart = (autoStart !== undefined) ? autoStart : true;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
    
    if (this.autoStart) this.start();
  }
  
  start() {
    this.startTime = Date.now();
    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  }
  
  stop() {
    this.getElapsedTime();
    this.running = false;
  }
  
  getElapsedTime() {
    this.getDelta();
    return this.elapsedTime;
  }
  
  getDelta() {
    let diff = 0;
    if (this.running) {
      const newTime = Date.now();
      diff = (newTime - this.oldTime) / 1000;
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }
    return diff;
  }
}

// 常量
const DoubleSide = 2;

// 导出
export {
  Vector3,
  Quaternion,
  Euler,
  Matrix4,
  Scene,
  PerspectiveCamera,
  WebGLRenderer,
  Group,
  Mesh,
  BufferGeometry,
  BufferAttribute,
  SphereGeometry,
  RingGeometry,
  MeshBasicMaterial,
  MeshStandardMaterial,
  PointsMaterial,
  PointLight,
  AmbientLight,
  Points,
  Clock,
  CanvasTexture,
  DoubleSide
};

// 默认导出
export default {
  Vector3,
  Quaternion,
  Euler,
  Matrix4,
  Scene,
  PerspectiveCamera,
  WebGLRenderer,
  Group,
  Mesh,
  BufferGeometry,
  BufferAttribute,
  SphereGeometry,
  RingGeometry,
  MeshBasicMaterial,
  MeshStandardMaterial,
  PointsMaterial,
  PointLight,
  AmbientLight,
  Points,
  Clock,
  CanvasTexture,
  DoubleSide
}; 